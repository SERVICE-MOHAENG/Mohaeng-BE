name: Deploy Prod

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: deploy-prod
  cancel-in-progress: false

jobs:
  build_and_push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set image variables
        id: image
        env:
          # Support both secret naming conventions.
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME || secrets.DOCKER_HUB_USERNAME }}
        run: |
          # Prefer explicit Docker Hub image (e.g. "dongguli08/mohaeng" or "docker.io/dongguli08/mohaeng").
          # Fallback: "<dockerhub_username>/mohaeng"
          # Intentionally do NOT fallback to GitHub repo owner (e.g. "service-mohaeng"), to avoid pushing to the wrong Docker Hub namespace.
          IMAGE_NAME="${{ secrets.DOCKERHUB_IMAGE }}"
          if [ -z "$IMAGE_NAME" ]; then
            if [ -n "${DOCKERHUB_USERNAME:-}" ]; then
              IMAGE_NAME="docker.io/${DOCKERHUB_USERNAME}/mohaeng"
            else
              echo "Missing DOCKERHUB_IMAGE (or DOCKERHUB_USERNAME/DOCKER_HUB_USERNAME). Set DOCKERHUB_IMAGE to e.g. 'dongguli08/mohaeng'."
              exit 1
            fi
          fi
          # Normalize: ensure docker.io prefix so the deploy step can safely `docker login` and pull.
          case "$IMAGE_NAME" in
            docker.io/*) ;;
            */*) IMAGE_NAME="docker.io/$IMAGE_NAME" ;;
            *) echo "Invalid DOCKERHUB_IMAGE: $IMAGE_NAME"; exit 1 ;;
          esac
          IMAGE_TAG="${{ github.sha }}"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          # Support both secret naming conventions:
          # - DOCKERHUB_USERNAME / DOCKERHUB_TOKEN
          # - DOCKER_HUB_USERNAME / DOCKER_HUB_TOKEN
          username: ${{ secrets.DOCKERHUB_USERNAME || secrets.DOCKER_HUB_USERNAME || secrets.GHCR_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN || secrets.DOCKER_HUB_TOKEN || secrets.GHCR_TOKEN }}

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Build and push docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ steps.image.outputs.image_name }}:${{ steps.image.outputs.image_tag }}
            ${{ steps.image.outputs.image_name }}:latest

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_push
    environment: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Upload docker compose file to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_PORT }}
          source: "docker-compose.prod.yml,infra/nginx/default.conf.template"
          target: /tmp

      - name: Deploy docker image over SSH
        uses: appleboy/ssh-action@v1.2.2
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_PORT }}
          script: |
            set -euo pipefail
            APP_DIR="${{ secrets.APP_DIR }}"
            IMAGE_NAME="${{ secrets.DOCKERHUB_IMAGE }}"
            DOCKERHUB_USERNAME="${{ secrets.DOCKERHUB_USERNAME || secrets.DOCKER_HUB_USERNAME || secrets.GHCR_USERNAME }}"
            DOCKERHUB_TOKEN="${{ secrets.DOCKERHUB_TOKEN || secrets.DOCKER_HUB_TOKEN || secrets.GHCR_TOKEN }}"
            IMAGE_TAG="${{ github.sha }}"
            PROD_ENV_FILE="${{ secrets.PROD_ENV_FILE }}"
            HEALTHCHECK_URL="${{ secrets.HEALTHCHECK_URL }}"

            # Trim accidental whitespace/newlines in secrets.
            DOCKERHUB_USERNAME="$(echo "$DOCKERHUB_USERNAME" | tr -d '[:space:]')"
            IMAGE_NAME="$(echo "$IMAGE_NAME" | tr -d '[:space:]')"

            if [ -z "$IMAGE_NAME" ]; then
              if [ -n "$DOCKERHUB_USERNAME" ]; then
                IMAGE_NAME="docker.io/${DOCKERHUB_USERNAME}/mohaeng"
              else
                echo "Missing DOCKERHUB_IMAGE (or DOCKERHUB_USERNAME/DOCKER_HUB_USERNAME)."
                exit 1
              fi
            fi

            case "$IMAGE_NAME" in
              docker.io/*) ;;
              */*) IMAGE_NAME="docker.io/$IMAGE_NAME" ;;
              *) echo "Invalid DOCKERHUB_IMAGE: $IMAGE_NAME"; exit 1 ;;
            esac

            if [ -z "$IMAGE_NAME" ] || [ -z "$IMAGE_TAG" ]; then
              echo "IMAGE_NAME or IMAGE_TAG is empty."
              exit 1
            fi

            mkdir -p "$APP_DIR"
            mkdir -p "$APP_DIR/infra/nginx"
            cd "$APP_DIR"
            cp /tmp/docker-compose.prod.yml "$APP_DIR/docker-compose.prod.yml"
            cp /tmp/infra/nginx/default.conf.template "$APP_DIR/infra/nginx/default.conf.template"

            # Prefer writing the production .env from GitHub Secrets.
            # If PROD_ENV_FILE is not set, keep an existing .env on the server (if present).
            if [ -n "$PROD_ENV_FILE" ]; then
              umask 077
              printf "%s" "$PROD_ENV_FILE" > .env
            elif [ ! -f .env ]; then
              echo "Missing PROD_ENV_FILE secret and $APP_DIR/.env does not exist."
              exit 1
            fi

            # docker compose variable interpolation reads --env-file values.
            # Merge runtime app env (.env) with deploy metadata (DOCKER_IMAGE).
            cp .env .deploy.env
            echo "DOCKER_IMAGE=$IMAGE_NAME:$IMAGE_TAG" >> .deploy.env

            # If the Docker Hub repo is private, login is required.
            if [ -n "$DOCKERHUB_USERNAME" ] && [ -n "$DOCKERHUB_TOKEN" ]; then
              echo "$DOCKERHUB_TOKEN" | docker login -u "$DOCKERHUB_USERNAME" --password-stdin
            fi

            docker compose --env-file .deploy.env -f docker-compose.prod.yml pull
            docker compose --env-file .deploy.env -f docker-compose.prod.yml up -d --remove-orphans

            if [ -n "$HEALTHCHECK_URL" ]; then
              curl -fsS "$HEALTHCHECK_URL" >/dev/null
            fi

            docker image prune -af --filter "until=168h" || true
