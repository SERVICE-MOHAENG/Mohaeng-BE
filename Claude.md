이 프로젝트는 NestJS기반의 프로젝트이며 다음과 같은 프로젝트 코드 규칙을 준수해야 한다.
1.DDD 아키텍처: 도메인별 entity,persistence,presentation,service,exception 폴더 분리, exception 내부 auth,code로 세부구분, 각 계층은 명확한 책임과 독립성 유지
2.파일 네이밍: PascalCase, 엔티티 *.entity.ts, 예외 Exception.ts, 인터페이스 *.interface.ts, 열거형 *.enum.ts, 컨트롤러 Controller.ts, 서비스 Service.ts/ApplicationService.ts, 리포지토리 Repository.ts
3.엔티티 정의: @Entity('user_table') \n export class User { @PrimaryColumn({name:'user_id'}) id:string; @Column({name:'user_name',nullable:false}) name:string; @Column({name:'email',nullable:false,default:''}) email:string; static create(name:string,email:string):User { const user=new User(); user.id=crypto.randomUUID(); user.name=name; user.email=email; return user; } }
4.예외 처리: export enum UserErrorCode { USER_NOT_FOUND='HE_010101', INVALID_EMAIL='HE_010102'} \n export class UserNotFoundException extends HttpException { constructor(){ super(ApiResponseDto.error(UserErrorCode.USER_NOT_FOUND,'사용자를 찾을 수 없습니다'),HttpStatus.NOT_FOUND);} }
5.컨트롤러: @ApiTags('users') \n@Controller('v1/users') \n@UseInterceptors(ResponseInterceptor) \n export class UserController { @Get(':id') async getUser(@Param('id')id:string){ const user=await this.userService.findById(id); return {user}; } @Post() async createUser(@Body()request:CreateUserRequest){ const user=await this.userService.create(request); return {user}; } }
6.서비스 구분: ApplicationService=도메인로직조율, Service=비즈니스로직. 예) export class UserApplicationService { constructor(private readonly userService:UserService, private readonly emailService:EmailService){} async createUserWithWelcomeEmail(request:CreateUserRequest){ const user=await this.userService.create(request); await this.emailService.sendWelcome(user.email); return user; } } \n export class UserService { constructor(@InjectRepository(User) private readonly userRepository:Repository<User>){} async create(request:CreateUserRequest):Promise<UserResponse>{ const user=User.create(request.name,request.email); await this.userRepository.save(user); return {id:user.id,name:user.name}; } }
7.리포지토리 패턴: export class UserRepository { constructor(@InjectRepository(User) private readonly repository:Repository<User>){} async findById(id:string):Promise<User|null>{ return this.repository.findOne({where:{id}});} async save(user:User):Promise<User>{ return this.repository.save(user);} }
8.Swagger 문서화: @ApiTags('users') \n@Controller('v1/users') \n export class UserController { @Get(':id') @ApiOperation({summary:'사용자 조회'}) @ApiParam({name:'id',description:'사용자ID'}) @ApiResponse({status:200,type:UserResponse}) async getUser(){} } \n export class CreateUserRequest { @ApiProperty({description:'사용자명',example:'홍길동'}) @IsString() name:string; }
9.인증 권한 데코레이터: 관리자 - 특정 권한 필요 @AdminApiBearerAuth(AdminPermission.PRODUCT_MANAGEMENT) async createProduct(@CurrentAdmin() admin: AdminUser) { // 구현 } # 관리자 - 여러 권한 중 하나 @AdminApiBearerAuth([AdminPermission.ORDER_MANAGEMENT, AdminPermission.PAYMENT_MANAGEMENT]) async getStats(@AdminId() adminId: string) { // 구현 } # 사용자 - JWT 인증 필요 @UserApiBearerAuth() async getMyOrders(@UserId() userId: string) { // 구현 } # 모든 관리자 접근 가능 @AdminApiBearerAuth() async getSystemInfo(@CurrentAdmin() admin: AdminUser) { // 구현 }ChatGPT의 말: 관리자/사용자 인증은 @AdminApiBearerAuth(권한 지정·복수 권한 허용·모든 관리자 접근)와 @UserApiBearerAuth(JWT 사용자 인증) 데코레이터로 제어하며, @CurrentAdmin, @AdminId, @UserId, @CurrentUser 파라미터 데코레이터로 로그인 주체 정보나 ID를 주입할 수 있고, 권한은 AdminPermission enum으로 정의하여 세분화된 접근 통제가 가능함.
10.주석 문서화: /** 사용자생성 \n@description \n - 신규사용자등록처리 \n - 이메일중복검증 \n - 환영메일발송 \n @param request - 사용자생성요청 \n @returns Promise<UserResponse> 생성된사용자정보 \n @throws {EmailAlreadyExistsException} 이메일중복시 */ async createUser(request:CreateUserRequest):Promise<UserResponse>
11.가이드라인: 새 도메인 추가시 entity,persistence,service,presentation,exception 폴더 생성. 컨트롤러=HTTP매핑전담, 반환시 객체래핑 필수. ApplicationService=도메인조율, Service=비즈니스로직. static create로 엔티티팩토리 구현, crypto.randomUUID()로 ID 생성. 각 폴더 index.ts로 export 처리
12.MCP(file_system) 사용시 실제 엔터 사용, '\n' 문자열 사용 금지. 위 프로젝트 가이드라인 문서 내 '\n'은 줄바꿈 위치 설명용 표기이며, 실제 코드(엔티티, 컨트롤러, 주석 등)에서는 절대 사용하지 말고 반드시 엔터 적용
13.DTO 구조: presentation/dto/request=요청DTO, presentation/dto/response=응답DTO. validation데코레이터 적극활용. 예) export class CreateUserRequest { @ApiProperty({description:'사용자명'}) @IsString() @IsNotEmpty() name:string; @ApiProperty({description:'이메일'}) @IsEmail() email:string; }
14.모듈 규칙: 도메인별 독립 ModuleClass 생성, 의존성주입 명확히 정의, 순환참조 방지. 예) @Module({ imports:[TypeOrmModule.forFeature([User])], controllers:[UserController], providers:[UserService,UserRepository], exports:[UserService] }) export class UserModule {}
15.Barrel export(index.ts)는 프로젝트 전체에서 금지한다. 단, exception/code/index.ts에서 에러 코드 export를 모아내는 경우만 예외로 허용한다. 모든 import 구문은 반드시 실제 파일명을 명시한다.
16.테스트 가이드라인: 유닛테스트=서비스계층중심, 컨트롤러=통합테스트, 모킹=외부의존성만, 실패시나리오 포함필수
17.성능 최적화: N+1 쿼리 방지, 페이징 필수, 캐싱전략 수립, DB 인덱스 최적화
18.프로젝트 상태: admin,logging,point,service=활성화, catalog,likes,product=컨트롤러 주석처리, user=entity+presentation만 존재
21.명명 규칙: 파일명=PascalCase(UserController.ts), 클래스=PascalCase(UserController), 메서드=camelCase(getUser), 변수=camelCase(userId), 상수=UPPER_SNAKE_CASE(ADMIN_PERMISSIONS_KEY), 인터페이스=PascalCase(UserInterface), 타입=PascalCase+Type(UserType), 열거형=PascalCase+Enum(UserStatusEnum), 데코레이터=camelCase(@currentUser), 폴더=lowercase(user), 도메인=단수형(user)
22.TypeScript 규칙: strict:true, 타입명시필수, nullable 명확히(string|null), Promise타입명시, async/await 패턴, any 금지, 제네릭 적극활용(<T>), optional체이닝(user?.name), nullish coalescing(user??defaultUser), 타입가드 구현, interface보다 type alias 선호경우 명시, 유니온타입 적극활용(string|number)
23.데코레이터 규칙: NestJS 데코레이터 순서준수(@Controller->@UseInterceptors->@Get), Swagger 데코레이터는 메서드 바로 위(@ApiOperation,@ApiResponse), 인증데코레이터=메서드레벨(@AdminApiBearerAuth), 파라미터데코레이터 순서(@Param,@Body,@Query), validation데코레이터=DTO프로퍼티에 적용(@IsString,@IsEmail), 커스텀데코레이터=global/decorators 관리
24.임포트 규칙: NestJS core 패키지 우선 import, 써드파티 다음, 내부 모듈 마지막. 상대경로보다 절대경로 선호, barrel export(index.ts) 사용절대금지, 수동 import 문 작성 , 순환참조 방지, 불필요한 import 제거 필수
25.에러 핸들링: 서비스계층에서 예외처리, 컨트롤러=예외전파만, try-catch 남용 금지, 도메인별 예외 클래스 정의, HttpException 상속, 에러코드 enum 관리, 사용자친화 메시지 제공, 로그레벨 구분(error,warn,info)
26.DB엔티티 변경이 있다면 사용자에게 알리고 필요한 DDL문을 아티팩트로 (MCP (filesystem)으로 적지 말껏) 사용자한테 넘기기
